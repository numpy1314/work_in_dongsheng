# 初始化
## _start() （modules/axhal/src/platform/aarch64_common/boot.rs）
```rust
core::arch::asm!("
        ldr x8, ={exception_vector_base_el2}    // setup vbar_el2 for hypervisor
        msr vbar_el2, x8

        // 将 exception_vector_base_el2 这个符号的地址作为立即数。exception_vector_base_el2 是一个 Rust 符号，代表 EL2 异常向量
        // 表的基地址。在汇编展开时，{exception_vector_base_el2} 会被替换为该符号对应的实际地址。
        //
        // msr：这是 ARM64 架构中的存储指令，用于将寄存器的值写入到内存中。msr 后面跟寄存器时，会将寄存器的值写入到指定的内存地址中。
        //
        // vbar_el2：全称是 Vector Base Address Register for Exception Level 2，即 EL2 异常级别下的异常向量表基地址寄存器。
        // 在 ARM64 架构里，不同异常级别（如 EL0、EL1、EL2、EL3）都有各自的异常向量表，用于处理各类异常事件，像中断、系统调用等。
        // vbar_el2 寄存器存储着 EL2 异常级别下异常向量表的基地址。
        //
        // x8：ARM64 架构中的一个 64 位通用寄存器。在之前的代码 ldr x8, ={exception_vector_base_el2} 里，已经把 EL2 异常向量表的
        // 基地址加载到了 x8 寄存器中。


        mrs     x19, mpidr_el1
        and     x19, x19, #0xffffff     // get current CPU id
        mov     x20, x0                 // save DTB pointer
        adrp    x8, {boot_stack}        // setup boot stack
        add     x8, x8, {boot_stack_size}
        mov     sp, x8

        // mrs：这是 ARM64 架构中的 “Move to General register from Special-register” 指令，作用是将特殊寄存器的值移动到通用寄存
        // 器中。
        //
        // mpidr_el1：全称是 Multiprocessor Affinity Register for Exception Level 1，即 EL1 异常级别下的多处理器亲和寄存器。这
        // 个寄存器存储了当前处理器核心的多处理器亲和信息，包含了核心 ID、集群 ID 等，可用于识别不同的 CPU 核心。
        //
        // and：这是按位与操作指令，在 ARM64 架构里，and 指令会对两个操作数的对应位进行与运算，只有当两个对应位都为 1 时，结果位才为 1，
        // 否则为 0。
        //
        // x19：ARM64 架构中的 64 位通用寄存器。在这行代码里，第一个 x19 是目标寄存器，用于存储按位与运算后的结果；第二个 x19 是源操作数
        // 寄存器，提供参与运算的一个值。
        //
        // #0xffffff：这是一个立即数，以十六进制表示。在二进制中，0xffffff 是低位 24 个 1，这行代码的作用是对 x19 寄存器中的值和立即
        // 数 0xffffff 进行按位与运算，然后把结果存回 x19 寄存器。（但真的是低24位吗）
        //
        // mov：这是 ARM64 架构中的移动指令，用于将一个寄存器的值复制到另一个寄存器，或者将一个立即数加载到寄存器中。在该指令里，它的作用
        // 是把一个寄存器的值复制到另一个寄存器。
        //
        // x20：ARM64 架构中的 64 位通用寄存器，作为目标寄存器，用于存储复制过来的值。
        //
        // x0：同样是 ARM64 架构中的 64 位通用寄存器，作为源寄存器，其存储的值会被复制到 x20 寄存器。
        //
        // adrp：这是 ARM64 架构中的伪指令，全称为 “ADd Relative Page”，即添加相对页地址。它的作用是将一个符号地址的高 48 位（页地址
        // 部分）计算出来，并将其左移 12 位后加上当前指令地址的高 48 位，最终结果存到目标寄存器中。简单来说，adrp 会把一个符号地址所在的页
        // 的基地址加载到目标寄存器。
        //
        // x8：ARM64 架构中的 64 位通用寄存器，作为目标寄存器，用于存储 adrp 指令计算得到的页基地址。adrp 指令会计算 boot_stack 符号
        // 地址所在页的基地址，然后将这个页基地址加载到 x8 寄存器中。由于 adrp 只处理地址的高 48 位，所以得到的地址是按 4KB 页对齐的。
        // 
        // {boot_stack}：这是一个 Rust 符号，代表启动栈的地址。在汇编展开时，{boot_stack} 会被替换为该符号对应的实际地址。
        //
        // add：这是 ARM64 架构中的加法指令，用于将两个操作数相加，并把结果存到目标寄存器中。
        //
        // x8：ARM64 架构中的 64 位通用寄存器。在这条指令里，第一个 x8 是目标寄存器，用于存储相加后的结果；第二个 x8 是源操作数寄存器，
        // 提供参与加法运算的一个值。
        //
        // {boot_stack_size}：这是一个 Rust 符号，代表启动栈的大小。在汇编展开时，{boot_stack_size} 会被替换为该符号对应的实际数值，
        // 结合上下文，在这行代码之前有 adrp x8, {boot_stack} 指令，该指令将启动栈所在页的基地址加载到了 x8 寄存器。而 add x8, x8, 
        // {boot_stack_size} 指令会把 x8 寄存器中的值（启动栈所在页的基地址）与启动栈的大小 {boot_stack_size} 相加，然后把结果存回 
        // x8 寄存器。这样，x8 寄存器就指向了启动栈的栈顶地址。
        // 由此，mov sp, x8 指令将 x8 寄存器中的值（启动栈的栈顶地址）加载到 sp 寄存器，这样 sp 寄存器就指向了启动栈的栈顶，
        // 栈顶地址就是启动栈的最大地址，栈底地址就是启动栈的最小地址。

        bl      {init_boot_page_table}
        bl      {init_mmu_el2}
        bl      {init_mmu}              // setup MMU
        bl      {switch_to_el1}         // switch to EL1
        bl      {enable_fp}             // enable fp/neon

        // bl：这是 ARM64 架构中的分支并链接（Branch with Link）指令。执行该指令时，处理器会将下一条指令的地址（即返回地址）保存到链接
        // 寄存器 LR（通常是 x30 寄存器）中，然后跳转到指定的目标地址去执行代码。当目标代码执行完毕后，可通过 ret 指令利用 LR 寄存器中的
        // 返回地址返回到原调用处继续执行。
        // 
        // 由此，这几行代码的意义是去调用这几个函数，再回来执行

        mov     x8, {phys_virt_offset}  // set SP to the high address
        add     sp, sp, x8

        mov     x0, x19                 // call rust_entry(cpu_id, dtb)
        mov     x1, x20
        ldr     x8, ={entry}
        blr     x8
        b      .",
        exception_vector_base_el2 = sym exception_vector_base_el2,
        init_boot_page_table = sym init_boot_page_table,
        init_mmu_el2 = sym init_mmu_el2,
        switch_to_el1 = sym switch_to_el1,
        init_mmu = sym init_mmu,
        enable_fp = sym enable_fp,
        boot_stack = sym BOOT_STACK,
        boot_stack_size = const TASK_STACK_SIZE,
        phys_virt_offset = const axconfig::PHYS_VIRT_OFFSET,
        entry = sym crate::platform::rust_entry,
        options(noreturn),
    );
```