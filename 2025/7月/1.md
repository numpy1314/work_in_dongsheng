今日先把师兄的建议给接纳并修改了axcpu

然后是对看门狗驱动的学习编写https://gitee.com/phytium_embedded/phytium-linux-kernel/blob/linux-5.10/drivers/watchdog/sbsa_gwdt.c

```rust
 * ARM SBSA Generic Watchdog has two stage timeouts:
 * the first signal (WS0) is for alerting the system by interrupt,
 * the second one (WS1) is a real hardware reset.
 * More details about the hardware specification of this device:
 * ARM DEN0029B - Server Base System Architecture (SBSA)
 *
 * This driver can operate ARM SBSA Generic Watchdog as a single stage watchdog
 * or a two stages watchdog, it's set up by the module parameter "action".
 * In the single stage mode, when the timeout is reached, your system
 * will be reset by WS1. The first signal (WS0) is ignored.
 * In the two stages mode, when the timeout is reached, the first signal (WS0)
 * will trigger panic. If the system is getting into trouble and cannot be reset
 * by panic or restart properly by the kdump kernel(if supported), then the
 * second stage (as long as the first stage) will be reached, system will be
 * reset by WS1. This function can help administrator to backup the system
 * context info by panic console output or kdump.
```
简单来说，该驱动实现了对 SBSA 规范看门狗硬件的完整支持，其核心创新在于​​两阶段超时机制​​，为系统故障提供了更灵活的响应策略（如先收集日志再复位）。

通过模块参数动态配置工作模式，结合标准看门狗框架接口，确保了与用户态工具（如 /dev/watchdog）的兼容性

下面是一些问题的学习：

## kdump内核是什么
```
kdump 内核是 Linux 系统中用于在内核崩溃时​​捕获内存转储（vmcore）​​的专用内核，也称为​​捕获内核（Capture Kernel）​​。它与主系统内核（生产内核）协同工作，是内核崩溃转储机制（Kdump）的核心组件。以下是其关键特性详解：

 ​​1. 核心作用与定位​​
​​故障现场保留​​：当主内核因崩溃（如 Panic/Oops）无法运行时，kdump 内核立即接管，将主内核的完整内存状态保存为 vmcore 文件，避免数据丢失。

​​独立运行环境​​：通过预留的内存区域启动，与主内核隔离，确保崩溃时内存内容不被覆盖。


​​2. 工作原理​​
​​内存预留​​：主内核启动时，通过启动参数（如 crashkernel=512M）保留一块专属内存（如 512MB），供 kdump 内核加载使用

​​快速切换（kexec）​​：崩溃时通过 kexec 机制直接跳转到预留内存中的 kdump 内核，跳过 BIOS/UEFI 初始化，实现毫秒级切换。

​​内存转储生成​​：kdump 内核将主内核的内存映射为 /proc/vmcore，并调用工具（如 makedumpfile）将其压缩保存至磁盘（如 /var/crash）。

​3. 关键特性​​

​​极简设计​​：
仅包含必要驱动和功能（如磁盘访问、网络传输）
通常仅启用单 CPU 核心以减少资源占用。

​​依赖组件​​：
​​kexec-tools​​：用户态工具，用于加载 kdump 内核到预留内存。
​​initramfs​​：最小化根文件系统，包含转储脚本和工具（如 crash）。

​4. 配置要点​​
​​内存预留​​：
典型配置：crashkernel=512M（物理内存 >16GB 时建议 ≥1GB）。
支持动态分配（如 crashkernel=auto），按系统内存自动调整。
​​内核支持​​：需启用编译选项：
CONFIG_CRASH_DUMP=y  
CONFIG_DEBUG_INFO=y  # 支持调试符号[1,5](@ref)。

​​服务管理​​：
Ubuntu：通过 kdump-tools.service 控制
RHEL：使用 kdump.service。

​​5. 典型工作流程​​
​​预留内存​​ → 主内核启动时保留 crashkernel 区域。
​​预加载内核​​ → kexec -p 将 kdump 内核加载至预留内存。
​​触发崩溃​​ → 主内核崩溃（如 echo c > /proc/sysrq-trigger）。
​​切换与转储​​ → kdump 内核启动，生成 /var/crash/YYYYMMDD/vmcore。
​​分析调试​​ → 使用 crash 工具分析 vmcore 和带调试符号的 vmlinux。

​总结​​
kdump 内核是 Linux 内核调试的“黑匣子”，通过​​隔离内存+快速切换​​的机制，在内核崩溃时完整保存故障现场。其有效性依赖于预留内存的合理配置、轻量化设计及自动化服务管理。运维与内核开发者需掌握其配置（如 crashkernel 参数）和分析方法（crash 工具），以快速定位系统级故障。
```

## kexec是什么
```
kexec机制
kexec简介
Kexec是基于kexec机制工作的，因此先了解一下Kexec。

kexec是一个快速启动机制，允许通过已经运行的内核的上下文启动一个Linux内核，不需要经过BIOS。（BIOS可能会消耗很多时间，特别是带有众多数量的外设的大型服务器。这种办法可以为经常启动机器的开发者节省很多时间。）

Kexec的实现包括2个组成部分：

** 一是内核空间的系统调用：kexec_load() **，负责在生产内核（production kernel 或 first kernel）启动时将捕获内核（capture kernel或sencond kernel）加载到指定地址。

** 二是用户空间的工具kexec-tools **，他将捕获内核的地址传递给生产内核，从而在系统崩溃的时候能够找到捕获内核的地址并运行。没有kexec就没有kdump。先有kexec实现了在一个内核中可以启动另一个内核，才让kdump有了用武之地。

kexec_load()
kexec 在 kernel 里以一个系统调用 kexec_load()的形式提供给用户。这个系统调用主要用来把另一个内核和其 ramdisk 加载到当前内核中。在 kdump中，捕获内核只能使用事先预留的一小段内存。

生产内核的内存镜像会被以 /proc/vmcore 的形式提供给用户。这是一个 ELF格式的方件，它的头是由用户空间工具 kexec 生成并传递来的。在系统崩溃时，系统最后会调用machine_kexec()。这通常是一个硬件相关的函数。它会引导捕获内核，从而完成 kdump 的过程。

kexec-tools
kdump 的很大一部分工作都是在用户空间内完成的。与 kexec相关的集中在一个叫kexec-tools的工具中的kexec程序中。

该程序主要是为调用 kexec_load()收集各种信息，然后调用之。这些信息主要包括 purgatory 的入口地址，还有一组由 struct kexec_segment描述的信息。
```
## vmcore是什么
```
vmcore 是 ​​Linux 系统内核崩溃时生成的内存转储文件​​，记录了崩溃瞬间的完整物理内存状态及内核关键数据，用于诊断系统崩溃的根本原因。以下是其核心要点：

⚙️ ​​1. 核心定义与作用​​
​​内核故障快照​​：当 Linux 内核发生严重错误（如硬件故障、驱动崩溃或内核代码缺陷）时，vmcore 会捕获崩溃瞬间的物理内存内容、CPU 寄存器状态、进程列表、堆栈跟踪等关键信息。

​​诊断核心工具​​：通过分析 vmcore，可定位崩溃原因（如空指针访问、内存泄漏、死锁等），提升系统稳定性。

⚡ ​​2. 生成机制​​
​​依赖 Kdump 服务​​：
vmcore 由 ​​kdump 机制​​自动生成。主内核崩溃时，kdump 启动预留内存中的 ​​捕获内核​​，将主内核的内存快照保存为 vmcore。
​​配置要求​​：需预留内存（如启动参数 crashkernel=512M）并启用 kdump 服务。
​​存储位置​​：默认保存在 /var/crash/ 目录下，文件大小与物理内存一致（如 64GB 内存生成 64GB 的 vmcore）。

🔍 ​​3. 核心内容​​
vmcore 文件包含崩溃时的完整系统状态：

​​物理内存数据​​：所有内存页的原始内容。
​​进程与线程信息​​：崩溃瞬间的活动进程列表及上下文。
​​硬件状态​​：CPU 寄存器值、设备驱动状态、中断请求（IRQ）记录。
​​内核结构​​：虚拟内存映射、文件系统缓存、网络连接状态等。
​​崩溃元数据​​：错误类型（如 kernel BUG）、触发位置（指令指针 RIP）。

🛠️ ​​4. 分析方法​​
​​必需工具​​：
​​crash 工具​​：主流分析工具，需配合 ​​vmlinux 符号文件​​（含调试信息的内核镜像）解析内存地址。
示例命令：
crash /usr/lib/debug/boot/vmlinux-5.4.0-1-generic /var/crash/vmcore
​​关键命令​​：
bt：查看崩溃时的堆栈跟踪。
ps：列出崩溃时的进程状态。
vm：分析内存使用情况。

​​辅助工具​​：
​​vmcore-dmesg.txt​​：伴随 vmcore 生成的日志，记录崩溃前的内核消息（如 Oops 错误），可通过在线工具（如 Red Hat 的 Kernel Oops Analyzer）快速分析。
​​gdb/SystemTap​​：支持深度调试，但需手动解析符号。

⚠️ ​​5. 注意事项​​
​​符号文件匹配​​：分析 vmcore 时，​​vmlinux 必须与崩溃内核版本完全一致​​，否则无法解析地址。
​​安全与存储​​：
vmcore 可能包含敏感数据（如用户密码、加密密钥），需加密存储和传输。
大内存系统需确保磁盘空间充足（如 1TB 内存需预留 1TB 存储）。
​​性能影响​​：启用 kdump 会预留部分内存（通常 256MB–1GB），可能减少可用内存。

💎 ​​典型应用场景​​
​​场景​​	​​分析目标​​	​​工具/命令​​
内核空指针崩溃	定位 RIP 寄存器指向的代码行	crash + bt
内存泄漏	检查未释放的内存块及分配函数	crash + kmem
死锁问题	分析进程阻塞时的锁持有链	crash + lock
驱动崩溃	查看驱动模块状态及寄存器值	crash + mod

✅ ​​总结​​
vmcore 是 Linux 内核崩溃分析的基石，通过 ​​kdump 机制生成​​，需结合 ​​vmlinux 符号文件​​和 ​​crash 工具​​解析，为诊断硬件故障、内核缺陷提供不可替代的现场数据。运维人员应掌握其生成配置（预留内存、服务启用）和分析方法，以快速恢复系统并修复根因。
```