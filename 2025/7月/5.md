今日的工作主要是学习axvisor（3号其实整理了学习笔记，结果系统重装没了）

首先，axcisor是基于arceos发展起来的，但又相对独立，逐渐发展为一个虚拟机管理程序

目前主要还是对工作流程不太熟悉

### 对smp的理解
简单地理解为处理器的个数，其实是叫Symmetric Multi-Processing，对称多处理，是多处理器架构，所以一般单核情况下看到smp：1

对称主要指的是处理器在地位和功能上是平等的，可以进行并行处理和资源共享

### 对.S文件的理解
首先是他和.s文件的区别，S文件会经过汇编器的预处理，而s不会

两者都是汇编语言源文件，但s中包含的是汇编指令，在编译流程中会被汇编器处理生成对应的目标文件

S文件支持C预处理器的语法，比如宏定义条件编译等，经过预处理器处理时，预处理器会对宏进行展开、以及对条件编译指令进行处理，生成对应的汇编代码，此时再由汇编器处理生成目标文件

值得注意的是，在axvisor/scripts/lds中的linker.lds.S文件虽然扩展名是.S文件，但是他不是S文件，而是一个脚本文件，用来配置链接脚本

链接脚本主要是用来指定目标文件的链接地址、内存布局、加载地址等

在axvisor中，链接脚本是用汇编语言编写的，所以需要经过汇编器处理生成目标文件

### 对链接脚本的理解
链接脚本一般要包含下面的内容
- 生成的可执行文件的目标架构和输出格式，比如说
```rust
OUTPUT_ARCH(arm)        // 输出架构为arm
OUTPUT_FORMAT(elf32-littlearm) // 输出格式为elf32-littlearm
```

- 程序开始执行的起始位置
```rust
ENTRY(_start)        // 程序开始执行的起始位置为_start
// ENTRY 关键字后面跟着的符号（如 _start）就是程序的入口点，操作系统加载程序后会从此处开始执行。
```

- 基地址和地址计数器
```rust
// 这里拿axvisor的链接脚本举例
BASE_ADDRESS = %KERNEL_BASE%;
// 当看见SECTIONS时，说明开始定义代码段和数据段的位置了，换句话说，SECTIONS之前的内容都是链接脚本的配置内容，到了SECTIONS时，才是代码段和数据段的定义，用于告诉链接器接下来要指定各个段在内存中的分布和排列顺序
SECTIONS {
    . = BASE_ADDRESS;
    _skernel = .;
    // ...
}
// 定义了基地址，但这里可以进行自定义，具体的值可以自己直接设定一个0x10000000,也可以像这样，先用一个占位符，而后在链接时再进行替换
```
先写到这，先去吃饭了